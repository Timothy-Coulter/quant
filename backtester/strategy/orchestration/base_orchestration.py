"""Base classes and common utilities for strategy orchestrators."""

from __future__ import annotations

from abc import ABC, abstractmethod
from collections.abc import Callable, Mapping, MutableMapping, Sequence
from dataclasses import dataclass, field
from typing import Any, cast

import pandas as pd

from backtester.core.event_bus import Event, EventBus, EventFilter, EventPriority
from backtester.core.events import (
    MarketDataEvent,
    SignalEvent,
    create_signal_event,
)
from backtester.core.logger import get_backtester_logger

from .orchestration_strategy_config import (
    ConflictResolutionStrategy,
    OrchestrationConfig,
    OrchestratorType,
    StrategyKind,
    StrategyRole,
)


@dataclass(slots=True)
class StrategyRegistration:
    """Container tracking strategy metadata and runtime instance."""

    identifier: str
    strategy: Any
    kind: StrategyKind
    weight: float = 1.0
    priority: int = 0
    role: StrategyRole = StrategyRole.PRIMARY
    enabled: bool = True


@dataclass(slots=True)
class StrategySignal:
    """Signal generated by a strategy during an orchestration cycle."""

    strategy_id: str
    payload: dict[str, Any]
    weight: float
    priority: int
    role: StrategyRole
    timestamp: float | None = None

    @property
    def confidence(self) -> float:
        """Extract the reported confidence, defaulting to zero."""
        value = self.payload.get("confidence", 0.0)
        try:
            return float(value)
        except (TypeError, ValueError):
            return 0.0

    @property
    def signal_type(self) -> str:
        """Return the signal type in uppercase for comparison."""
        raw_value = self.payload.get("signal_type", "HOLD")
        return str(raw_value).upper()


@dataclass(slots=True)
class OrchestratorCycleResult:
    """Summary of an orchestration cycle."""

    symbol: str
    timestamp: float | None
    signals: list[StrategySignal] = field(default_factory=list)
    signal_events: list[SignalEvent] = field(default_factory=list)
    metadata: dict[str, Any] = field(default_factory=dict)

    @property
    def primary_signal(self) -> StrategySignal | None:
        """Convenience property returning the first signal if present."""
        return self.signals[0] if self.signals else None


class BaseStrategyOrchestrator(ABC):
    """Abstract base class for coordinating multiple trading strategies."""

    def __init__(
        self,
        config: OrchestrationConfig,
        event_bus: EventBus | None = None,
    ) -> None:
        """Create a new orchestrator with the provided configuration and event bus."""
        self.config = config
        self.event_bus = event_bus or EventBus()
        self.logger = get_backtester_logger(__name__)
        self._strategies: MutableMapping[str, StrategyRegistration] = {}
        self._last_result: OrchestratorCycleResult | None = None

        # Listen for externally generated signal events in case other components publish them.
        def _signal_handler(event: Event) -> None:
            if isinstance(event, SignalEvent):
                self._record_external_signal(event)

        self._signal_subscription_id = self.event_bus.subscribe(
            _signal_handler,
            EventFilter(event_types={"SIGNAL"}),
        )

    # ------------------------------------------------------------------#
    # Strategy registration
    # ------------------------------------------------------------------#
    def register_strategy(
        self,
        identifier: str,
        strategy: Any,
        *,
        kind: StrategyKind | None = None,
        weight: float | None = None,
        priority: int | None = None,
        role: StrategyRole | None = None,
        enabled: bool | None = None,
    ) -> None:
        """Register a strategy instance with the orchestrator."""
        reference = self.config.get_strategy(identifier)

        resolved_kind = kind or (reference.kind if reference else StrategyKind.SIGNAL)
        resolved_weight = weight if weight is not None else (reference.weight if reference else 1.0)
        resolved_priority = (
            priority if priority is not None else (reference.priority if reference else 0)
        )
        resolved_role = role or (reference.role if reference else StrategyRole.PRIMARY)
        resolved_enabled = (
            enabled if enabled is not None else (reference.enabled if reference else True)
        )

        registration = StrategyRegistration(
            identifier=identifier,
            strategy=strategy,
            kind=resolved_kind,
            weight=resolved_weight,
            priority=resolved_priority,
            role=resolved_role,
            enabled=resolved_enabled,
        )
        self._strategies[identifier] = registration
        self.logger.debug(
            "Registered strategy %s (kind=%s, weight=%s, priority=%s, role=%s)",
            identifier,
            registration.kind.value,
            registration.weight,
            registration.priority,
            registration.role.value,
        )

    def unregister_strategy(self, identifier: str) -> None:
        """Remove a strategy from the orchestrator."""
        if identifier in self._strategies:
            del self._strategies[identifier]
            self.logger.debug("Unregistered strategy %s", identifier)

    def get_registered_strategies(self) -> Sequence[StrategyRegistration]:
        """Return the currently registered strategies."""
        return tuple(self._strategies.values())

    # ------------------------------------------------------------------#
    # Event handling and orchestration
    # ------------------------------------------------------------------#
    def on_market_data(
        self,
        event: MarketDataEvent,
        data: pd.DataFrame | None = None,
    ) -> OrchestratorCycleResult:
        """Process incoming market data and orchestrate strategy execution."""
        if data is None:
            data = self._data_from_event(event)

        if data is None or data.empty:
            self.logger.warning("Received market data event without usable payload.")
            result = OrchestratorCycleResult(symbol=event.symbol, timestamp=event.timestamp)
            self._last_result = result
            return result

        strategy_signals = self._coordinate_signals(event, data)
        resolved_signals = self._resolve_conflicts(strategy_signals)
        signal_events = self._dispatch_signal_events(event.symbol, resolved_signals, event)

        metadata = {
            "orchestrator_type": self.config.orchestrator_type.value,
            "strategy_count": len(self._strategies),
        }

        result = OrchestratorCycleResult(
            symbol=event.symbol,
            timestamp=event.timestamp,
            signals=resolved_signals,
            signal_events=signal_events,
            metadata=metadata,
        )
        self._last_result = result
        return result

    def process_events(self, timestamp: float | None = None) -> OrchestratorCycleResult | None:
        """Retrieve the most recent orchestration result for downstream consumers."""
        if self._last_result is None:
            return None
        # Return the existing object to avoid copying large signal payloads.
        return self._last_result

    # ------------------------------------------------------------------#
    # Abstract hooks for subclasses
    # ------------------------------------------------------------------#
    @abstractmethod
    def _coordinate_signals(
        self,
        event: MarketDataEvent,
        data: pd.DataFrame,
    ) -> list[StrategySignal]:
        """Produce a set of strategy signals for a market data event."""

    # ------------------------------------------------------------------#
    # Helpers
    # ------------------------------------------------------------------#
    def _resolve_conflicts(self, signals: list[StrategySignal]) -> list[StrategySignal]:
        """Resolve conflicting signals based on configuration."""
        if not signals:
            return []

        strategy = self.config.conflict_resolution

        def _first_signal() -> list[StrategySignal]:
            ordered = sorted(signals, key=lambda s: (s.priority, -s.confidence), reverse=False)
            return [ordered[0]]

        def _highest_confidence() -> list[StrategySignal]:
            return [max(signals, key=lambda s: (s.confidence, s.weight, -s.priority))]

        def _latest_signal() -> list[StrategySignal]:
            return [signals[-1]]

        def _weighted_merge() -> list[StrategySignal]:
            merged = self._merge_weighted_signals(signals)
            return [merged] if merged is not None else []

        def _consensus() -> list[StrategySignal]:
            consensus_type = self._find_consensus_signal_type(signals)
            if consensus_type is None:
                return []
            consensus_signals = [s for s in signals if s.signal_type == consensus_type]
            return [
                max(
                    consensus_signals,
                    key=lambda s: (s.confidence, s.weight, -s.priority),
                )
            ]

        handler_map: dict[ConflictResolutionStrategy, Callable[[], list[StrategySignal]]] = {
            ConflictResolutionStrategy.FIRST_SIGNAL: _first_signal,
            ConflictResolutionStrategy.HIGHEST_CONFIDENCE: _highest_confidence,
            ConflictResolutionStrategy.LATEST: _latest_signal,
            ConflictResolutionStrategy.WEIGHTED_MERGE: _weighted_merge,
            ConflictResolutionStrategy.CONSENSUS: _consensus,
        }

        handler = handler_map.get(strategy)
        if handler is None:
            return signals
        return handler()

    def _merge_weighted_signals(self, signals: Sequence[StrategySignal]) -> StrategySignal | None:
        """Combine signals into a single weighted representative signal."""
        if not signals:
            return None

        accumulator: dict[str, float] = {}
        confidence_accumulator: dict[str, float] = {}

        for signal in signals:
            signal_type = signal.signal_type
            accumulator[signal_type] = accumulator.get(signal_type, 0.0) + signal.weight
            confidence_accumulator[signal_type] = confidence_accumulator.get(signal_type, 0.0) + (
                signal.confidence * signal.weight
            )

        top_signal_type = max(accumulator, key=accumulator.__getitem__)
        total_weight = accumulator[top_signal_type]

        representative = max(
            (s for s in signals if s.signal_type == top_signal_type),
            key=lambda s: (s.confidence, s.weight, -s.priority),
        )

        avg_confidence = (
            confidence_accumulator[top_signal_type] / total_weight
            if total_weight
            else representative.confidence
        )

        payload = dict(representative.payload)
        payload["confidence"] = avg_confidence
        payload.setdefault("aggregation", {})["total_weight"] = total_weight

        return StrategySignal(
            strategy_id=representative.strategy_id,
            payload=payload,
            weight=total_weight,
            priority=representative.priority,
            role=representative.role,
            timestamp=representative.timestamp,
        )

    def _find_consensus_signal_type(self, signals: Sequence[StrategySignal]) -> str | None:
        """Identify the most common signal type if it has majority support."""
        counts: dict[str, int] = {}
        for signal in signals:
            counts[signal.signal_type] = counts.get(signal.signal_type, 0) + 1

        if not counts:
            return None

        consensus_type, occurrence = max(counts.items(), key=lambda item: item[1])
        if occurrence >= max(2, len(signals) // 2 + 1):
            return consensus_type
        return None

    def _dispatch_signal_events(
        self,
        symbol: str,
        signals: Sequence[StrategySignal],
        event: MarketDataEvent,
    ) -> list[SignalEvent]:
        """Create and publish signal events for downstream subscribers."""
        signal_events: list[SignalEvent] = []

        for strategy_signal in signals:
            payload = strategy_signal.payload
            signal_event = create_signal_event(
                symbol=symbol,
                signal_type=payload.get("signal_type", "HOLD"),
                strength=float(payload.get("strength", strategy_signal.confidence)),
                confidence=strategy_signal.confidence,
                source=strategy_signal.strategy_id,
                priority=(
                    EventPriority.HIGH
                    if strategy_signal.confidence >= 0.75
                    else EventPriority.NORMAL
                ),
                metadata={
                    **payload.get("metadata", {}),
                    "strategy_id": strategy_signal.strategy_id,
                    "raw_signal": payload,
                    "timestamp": event.timestamp,
                },
            )
            self.event_bus.publish(signal_event)
            signal_events.append(signal_event)

        return signal_events

    def _data_from_event(self, event: MarketDataEvent) -> pd.DataFrame | None:
        """Attempt to reconstruct a DataFrame from event metadata."""
        metadata = event.metadata or {}
        data = metadata.get("data_frame")
        if isinstance(data, pd.DataFrame):
            return data

        # Build a single-row DataFrame using event attributes as a fallback.
        if all(
            value is not None
            for value in (event.open_price, event.high_price, event.low_price, event.close_price)
        ):
            frame = pd.DataFrame(
                [
                    {
                        "Open": event.open_price,
                        "High": event.high_price,
                        "Low": event.low_price,
                        "Close": event.close_price,
                        "Volume": metadata.get("volume", 0.0),
                        "open": event.open_price,
                        "high": event.high_price,
                        "low": event.low_price,
                        "close": event.close_price,
                        "volume": metadata.get("volume", 0.0),
                    }
                ],
                index=[pd.Timestamp(event.timestamp, unit="s")],
            )
            return frame
        return None

    def _invoke_strategy(
        self,
        registration: StrategyRegistration,
        data: pd.DataFrame,
        symbol: str,
    ) -> list[StrategySignal]:
        """Invoke a strategy safely, normalising its output into StrategySignal instances."""
        strategy = registration.strategy
        generator = getattr(strategy, "generate_signals", None)
        if not callable(generator):
            raise AttributeError(
                f"Strategy {registration.identifier} lacks generate_signals method."
            )

        generator_callable = cast(
            Callable[..., Sequence[Mapping[str, Any]] | list[dict[str, Any]] | None],
            generator,
        )
        try:
            raw_signals_obj = generator_callable(data, symbol)
        except TypeError:
            raw_signals_obj = generator_callable(data)

        if raw_signals_obj is None:
            return []

        signals: list[StrategySignal] = []
        for payload in list(raw_signals_obj):
            payload_dict = dict(payload)
            metadata = payload_dict.get("metadata", {})
            if "confidence" not in payload_dict:
                inferred_confidence = metadata.get("confidence", 0.5)
                try:
                    payload_dict["confidence"] = float(inferred_confidence)
                except (TypeError, ValueError):
                    payload_dict["confidence"] = 0.5
            payload_dict["signal_type"] = str(payload_dict.get("signal_type", "HOLD")).upper()
            signals.append(
                StrategySignal(
                    strategy_id=registration.identifier,
                    payload=payload_dict,
                    weight=registration.weight,
                    priority=registration.priority,
                    role=registration.role,
                    timestamp=payload_dict.get("timestamp"),
                )
            )
        return signals

    def _record_external_signal(self, event: SignalEvent) -> None:
        """Handler recording externally emitted signals for diagnostics."""
        self.logger.debug(
            "Observed external signal %s from %s (confidence=%s)",
            event.signal_type.value,
            event.source,
            event.confidence,
        )

    # ------------------------------------------------------------------#
    # Factory helper
    # ------------------------------------------------------------------#
    @staticmethod
    def create(
        config: OrchestrationConfig,
        event_bus: EventBus | None = None,
    ) -> BaseStrategyOrchestrator:
        """Instantiate an orchestrator matching the configuration."""
        orchestrator_type = config.orchestrator_type

        if orchestrator_type == OrchestratorType.SEQUENTIAL:
            from .sequential_orchestrator import SequentialStrategyOrchestrator

            return SequentialStrategyOrchestrator(config=config, event_bus=event_bus)
        if orchestrator_type == OrchestratorType.PARALLEL:
            from .parallel_orchestrator import ParallelStrategyOrchestrator

            return ParallelStrategyOrchestrator(config=config, event_bus=event_bus)
        if orchestrator_type == OrchestratorType.MASTER_SLAVE:
            from .master_slave_orchestrator import MasterSlaveStrategyOrchestrator

            return MasterSlaveStrategyOrchestrator(config=config, event_bus=event_bus)
        if orchestrator_type == OrchestratorType.ENSEMBLE:
            from .ensemble_orchestrator import EnsembleStrategyOrchestrator

            return EnsembleStrategyOrchestrator(config=config, event_bus=event_bus)
        if orchestrator_type == OrchestratorType.CONDITIONAL:
            from .conditional_orchestrator import ConditionalStrategyOrchestrator

            return ConditionalStrategyOrchestrator(config=config, event_bus=event_bus)

        raise ValueError(f"Unsupported orchestrator type: {orchestrator_type.value}")
